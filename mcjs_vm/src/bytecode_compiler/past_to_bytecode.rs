//! PAST->Bytecode compiler.
//!
//! This is the second and last phase of the bytecode compiler, after the JavaScript->PAST
//! step.
//!
//! It works pretty much as you'd expect, taking full advantage of knowing the full set of
//! declarations of each scope/block.

// ## Error handling
//
// Compilation errors arising in this phase are to be considered fully unexpected, and are
// handled exclusively by panicking. (The panic is only caught at the topmost level in
// `compile_module` so that the entire application does not have to crash.) The motivation
// for this is twofold.
//
// First, a malformed PAST can come *exclusively* from a bug in the JavaScript->PAST
// phase, not from any mistake made by our user in their JavaScript code. Such user errors
// should be caught and reported by the JavaScript->PAST phase, in which case that phase
// terminates with an error, without producing any PAST.  If a PAST comes out of that
// phase, then it's supposed to be fully correct. There is no point in continuing the
// compilation in the presence of a certified bug.
//
// Second, interrupting the compilation 'in the middle' would leave our internal data
// structures in a logically invalid state, missing some invariants (details in the
// `builder` module). There is no easy way to prevent the ensuing problems, only hard ones
// (e.g. putting changes in an auxiliary structure to be committed/rolled-back afterwards;
// copying the FnBuilder, changing only one of the two copies and then discarding one of
// them).  But there is no point: if a compiler bug is detected, we might as well throw
// the entire thing out with just a message.

use std::collections::HashSet;

use swc_atoms::JsWord;

use super::js_to_past::{self, Block, DeclName, Stmt, StmtID, StmtOp};
use super::CompiledModule;

use crate::bytecode::{self, Instr, Literal};
use crate::common::Result;
use crate::{error, tracing};

use builder::{Compiler, Loc, ModuleBuilder};

pub fn compile_module(func: &js_to_past::Function, min_fnid: u32) -> Result<CompiledModule> {
    let res = std::panic::catch_unwind(move || {
        let mut module_builder = builder::ModuleBuilder::new(min_fnid);

        let globals: HashSet<_> = func.unbound_names.iter().cloned().collect();

        // Similar to `compile_function`, but we have no parameters, no captures,
        // and we define 'globalThis' at the root scope
        let mut cplr = builder::Compiler::new(&globals, &mut module_builder);
        cplr.set_strict_mode(func.strict_mode);

        let stmts_count = func.body.stmts().count();
        cplr.block(func.body.id, stmts_count, |cplr| {
            let reg = cplr.gen_reg();
            cplr.emit(Instr::GetGlobalThis(reg));
            cplr.define_name(DeclName::Js("globalThis".into()), reg);

            compile_block_internal(cplr, &func.body)
        });

        let root_lfnid = cplr.build(func.span);
        module_builder.build(root_lfnid)
    });

    match res {
        Ok(module) => {
            trace_dump_module(&module);
            Ok(module)
        }
        Err(payload) => {
            let message = if let Some(message) = payload.downcast_ref::<String>() {
                message
            } else {
                "<not a string>"
            };
            Err(error!(
                "past->bytecode internal module compilation error: {}",
                message
            ))
        }
    }
}

// TODO Refactor into trace_dump and impl util::Dump for CompiledModule
fn trace_dump_module(module: &CompiledModule) {
    let t = tracing::section("bytecode");
    for (fnid, func) in &module.functions {
        use std::io::Write;

        let mut buf = Vec::new();

        let mode_name = if func.is_strict_mode() {
            "strict"
        } else {
            "sloppy"
        };
        writeln!(buf, "mode: {}", mode_name).unwrap();

        writeln!(buf).unwrap();
        func.dump(&mut buf).unwrap();

        let buf = String::from_utf8(buf).unwrap();
        t.log(&format!("{:?}", fnid), &buf);
    }
}

fn compile_function<'a>(
    globals: &'a HashSet<JsWord>,
    module_builder: &'a mut ModuleBuilder,
    captures: Vec<DeclName>,
    func: &js_to_past::Function,
) -> bytecode::FnID {
    let mut cplr = builder::Compiler::new(globals, module_builder);
    cplr.set_strict_mode(func.strict_mode);

    let stmts_count = func.body.stmts().count();
    cplr.block(func.body.id, stmts_count, |cplr| {
        // We currently only support a limited number of arguments.
        // They're placed in the first (bytecode::ARGS_COUNT_MAX) vregs
        // automatically by the interpreter. We just prepare our data structures so
        // that the generated bytecode makes use of this fact.
        for (ndx, name) in func
            .parameters
            .iter()
            .take(bytecode::ARGS_COUNT_MAX as usize)
            .enumerate()
        {
            let reg = bytecode::VReg(ndx.try_into().unwrap());
            let decl_name = DeclName::Js(name.clone());
            cplr.define_name(decl_name, reg);
        }

        for (cap_ndx, cap_decl) in captures.into_iter().enumerate() {
            let cap_ndx = cap_ndx.try_into().unwrap();

            let reg = cplr.gen_reg();
            cplr.emit(Instr::LoadCapture(reg, bytecode::CaptureIndex(cap_ndx)));
            cplr.define_name(cap_decl, reg);
        }

        compile_block_internal(cplr, &func.body)
    });

    cplr.build(func.span)
}

fn compile_one_stmt<'a>(
    cplr: &mut Compiler,
    block: &Block,
    stmts: &mut impl Iterator<Item = &'a Stmt>,
) -> bool {
    let stmt = match stmts.next() {
        Some(stmt) => stmt,
        None => return false,
    };

    let iid_start = cplr.peek_iid();
    cplr.mark_stmt_start();

    match &stmt.op {
        StmtOp::Pending => {
            panic!("compiler bug: pending stmt left over from previous stage")
        }
        StmtOp::Break(block_id) => {
            let iid = cplr.reserve_instr();

            let block_id = *block_id;
            cplr.on_function_completion(move |cplr| {
                let (_, iid_end) = cplr.block_boundaries(block_id);
                cplr.set_instr(iid, Instr::Jmp(iid_end));
            });
        }
        StmtOp::Unshare(name) => {
            let loc = cplr.resolve_name(name);
            let reg = match loc {
                builder::Loc::Reg(reg) => reg,
                builder::Loc::Global(_) => {
                    panic!("malformed PAST: Unshared name must be local, not global")
                }
            };

            cplr.emit(Instr::Unshare(reg));
        }
        StmtOp::IfNot { test } => {
            // IfNot can be understood as "skip the next op if <test>"
            let cond = cplr.gen_reg();
            compile_expr(cplr, Some(cond), block, *test);
            let jmpif = cplr.reserve_instr();

            compile_one_stmt(cplr, block, stmts);

            let dest = cplr.peek_iid();
            cplr.set_instr(jmpif, Instr::JmpIf { cond, dest });
        }
        StmtOp::Assign(dest, value_eid) => {
            if let Some(dest) = dest {
                compile_assignment(cplr, dest, block, *value_eid);
            } else {
                // the dest register is then forgotten
                let _ = compile_expr(cplr, None, block, *value_eid);
            }
        }
        StmtOp::ArrayPush(arr, value_eid) => {
            let arr = compile_read(cplr, arr);
            let value = compile_expr(cplr, None, block, *value_eid);
            cplr.emit(Instr::ArrayPush { arr, value });
        }
        StmtOp::ObjectSet { obj, key, value } => {
            let obj_reg = compile_expr(cplr, None, block, *obj);
            let key_reg = compile_expr(cplr, None, block, *key);
            let value_reg = compile_expr(cplr, None, block, *value);
            cplr.emit(Instr::ObjSet {
                obj: obj_reg,
                key: key_reg,
                value: value_reg,
            });
        }
        StmtOp::Return(arg) => {
            let arg_reg = compile_expr(cplr, None, block, *arg);
            cplr.emit(Instr::Return(arg_reg));
        }

        StmtOp::Throw(arg) => {
            let arg_reg = compile_expr(cplr, None, block, *arg);
            cplr.emit(Instr::Throw(arg_reg));
        }
        StmtOp::Debugger => {
            cplr.emit(Instr::Breakpoint);
        }
        StmtOp::Block(child_block) => {
            compile_block(cplr, child_block);
        }
        StmtOp::Jump(target_sid) => {
            let iid = cplr.reserve_instr();
            let target_sid = *target_sid;
            cplr.on_block_completion(move |cplr| {
                let target = cplr.iid_of_stmt(target_sid);
                cplr.set_instr(iid, Instr::Jmp(target));
            });
        }
        StmtOp::SetResumePoint(target_sid) => {
            let iid = cplr.reserve_instr();
            let resume_sid = *target_sid;
            cplr.on_block_completion(move |cplr| {
                let resume_iid = cplr.iid_of_stmt(resume_sid);
                cplr.set_instr(iid, Instr::SaveFrameSnapshot(resume_iid));
            });
        }

        StmtOp::TryBegin { handler } => {
            let iid = cplr.reserve_instr();

            let handler = *handler;
            cplr.on_block_completion(move |cplr| {
                let handler_iid = cplr.iid_of_stmt(handler);
                cplr.set_instr(iid, Instr::PushExcHandler(handler_iid));
            });
        }
        StmtOp::TryEnd => {
            cplr.emit(Instr::PopExcHandler);
        }

        StmtOp::StrAppend(buf, chunk) => {
            let buf = compile_read(cplr, buf);
            let chunk = compile_expr(cplr, None, block, *chunk);
            cplr.emit(Instr::StrAppend(buf, chunk));
        }
    };

    if !stmt.span.is_dummy() {
        let iid_end = cplr.peek_iid();
        cplr.add_breakable_range(stmt.span, iid_start, iid_end);
    }

    true
}

fn compile_assignment(
    cplr: &mut Compiler,
    var_name: &DeclName,
    block: &Block,
    value_eid: js_to_past::ExprID,
) {
    match cplr.resolve_name(var_name) {
        Loc::Reg(reg) => {
            compile_expr(cplr, Some(reg), block, value_eid);
        }
        Loc::Global(name) => {
            let global_this = cplr.gen_reg();
            cplr.emit(Instr::GetGlobalThis(global_this));

            let key = cplr.gen_reg();
            compile_load_const(cplr, key, Literal::JsWord(name));

            let value = compile_expr(cplr, None, block, value_eid);

            cplr.emit(Instr::ObjSet {
                obj: global_this,
                key,
                value,
            });
        }
    };
}

fn compile_read(cplr: &mut Compiler<'_>, name: &DeclName) -> bytecode::VReg {
    match cplr.resolve_name(name) {
        Loc::Reg(reg) => reg,
        Loc::Global(name) => compile_read_global(cplr, name),
    }
}

fn compile_read_global(cplr: &mut Compiler<'_>, name_lit: JsWord) -> bytecode::VReg {
    let dest = cplr.gen_reg();
    let name = cplr.add_const(Literal::JsWord(name_lit));
    cplr.emit(Instr::GetGlobal { dest, name });
    dest
}
fn compile_load_const(cplr: &mut Compiler, dest: bytecode::VReg, lit: Literal) {
    // Avoid string clone?
    let const_ndx = cplr.add_const(lit);
    cplr.emit(Instr::LoadConst(dest, const_ndx));
}

fn compile_expr(
    cplr: &mut Compiler,
    forced_dest: Option<bytecode::VReg>,
    block: &Block,
    expr_id: js_to_past::ExprID,
) -> bytecode::VReg {
    use js_to_past::Expr;

    let get_dest = move |cplr: &mut Compiler| forced_dest.unwrap_or_else(|| cplr.gen_reg());

    let expr = block.get_expr(expr_id);
    match expr {
        Expr::Undefined => {
            let dest = get_dest(cplr);
            cplr.emit(Instr::LoadUndefined(dest));
            dest
        }
        Expr::Null => {
            let dest = get_dest(cplr);
            cplr.emit(Instr::LoadNull(dest));
            dest
        }
        Expr::This => {
            let dest = get_dest(cplr);
            cplr.emit(Instr::LoadThis(dest));
            dest
        }
        Expr::Read(DeclName::Js(name)) if name == "Infinity" => {
            let dest = get_dest(cplr);
            compile_load_const(cplr, dest, Literal::Number(f64::INFINITY));
            dest
        }
        Expr::Read(name) => {
            let src = compile_read(cplr, name);
            if let Some(forced_dest) = forced_dest {
                cplr.emit(Instr::Copy {
                    dst: forced_dest,
                    src,
                });
                forced_dest
            } else {
                src
            }
        }
        Expr::Unary(op, arg_eid) => {
            let dest = get_dest(cplr);

            match op {
                // TODO Ensuring that "dest" is always a fresh vreg is probably just
                // a "dumb" stop gap. A better solution would be to perform register
                // allocation on the bytecode, but I need to evaluate pros/cons.
                swc_ecma_ast::UnaryOp::Minus => {
                    let arg = compile_expr(cplr, forced_dest, block, *arg_eid);
                    cplr.emit(Instr::UnaryMinus { dest, arg });
                }
                swc_ecma_ast::UnaryOp::Bang => {
                    let arg = compile_expr(cplr, forced_dest, block, *arg_eid);
                    cplr.emit(Instr::BoolNot { dest, arg });
                }
                swc_ecma_ast::UnaryOp::TypeOf => {
                    let arg = compile_expr(cplr, forced_dest, block, *arg_eid);
                    cplr.emit(Instr::TypeOf { dest, arg });
                }
                swc_ecma_ast::UnaryOp::Void => {
                    let _ = compile_expr(cplr, forced_dest, block, *arg_eid);
                    cplr.emit(Instr::LoadUndefined(dest));
                }
                swc_ecma_ast::UnaryOp::Plus => {
                    let arg = compile_expr(cplr, forced_dest, block, *arg_eid);
                    cplr.emit(Instr::ToNumber { dest, arg });
                }
                swc_ecma_ast::UnaryOp::Delete => {
                    // TODO Adjust return value: true for all cases except when the property is an
                    // own non-configurable property, in which case false is returned in non-strict
                    // mode. (Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete)

                    match block.get_expr(*arg_eid) {
                        Expr::ObjectGet { obj, key } => {
                            let obj = compile_expr(cplr, None, block, *obj);
                            let key = compile_expr(cplr, None, block, *key);
                            cplr.emit(Instr::ObjDelete { obj, key });
                        }
                        _ => {}
                    }
                    let true_ = cplr.add_const(Literal::Bool(true));
                    cplr.emit(Instr::LoadConst(dest, true_));
                }
                swc_ecma_ast::UnaryOp::Tilde => {
                    panic!("unsupported unary op: {:?}", op)
                }
            }

            dest
        }
        Expr::Binary(op, left, right) => {
            let dest = get_dest(cplr);

            match op {
                swc_ecma_ast::BinaryOp::LogicalAnd => {
                    // Short-circuiting &&: return left if left is false; otherwise return right
                    compile_expr(cplr, Some(dest), block, *left);
                    let jmpif_iid = cplr.reserve_instr();
                    compile_expr(cplr, Some(dest), block, *right);
                    let after_pos = cplr.peek_iid();

                    cplr.set_instr(
                        jmpif_iid,
                        Instr::JmpIfNot {
                            cond: dest,
                            dest: after_pos,
                        },
                    );
                }
                swc_ecma_ast::BinaryOp::LogicalOr => {
                    // Short-circuiting ||: return right if left is true; otherwise return left
                    compile_expr(cplr, Some(dest), block, *left);
                    let jmpif_iid = cplr.reserve_instr();
                    compile_expr(cplr, Some(dest), block, *right);
                    let after_pos = cplr.peek_iid();

                    cplr.set_instr(
                        jmpif_iid,
                        Instr::JmpIf {
                            cond: dest,
                            dest: after_pos,
                        },
                    );
                }
                _ => {
                    let left = compile_expr(cplr, None, block, *left);
                    let right = compile_expr(cplr, None, block, *right);

                    let instr = match op {
                        swc_ecma_ast::BinaryOp::Add => {
                            let left = complex::compile_to_primitive(cplr, left);
                            let right = complex::compile_to_primitive(cplr, right);
                            Instr::OpAdd(dest, left, right)
                        }
                        swc_ecma_ast::BinaryOp::Sub => Instr::ArithSub(dest, left, right),
                        swc_ecma_ast::BinaryOp::Mul => Instr::ArithMul(dest, left, right),
                        swc_ecma_ast::BinaryOp::Div => Instr::ArithDiv(dest, left, right),
                        swc_ecma_ast::BinaryOp::Lt => Instr::CmpLT(dest, left, right),
                        swc_ecma_ast::BinaryOp::LtEq => Instr::CmpLE(dest, left, right),
                        swc_ecma_ast::BinaryOp::Gt => Instr::CmpGT(dest, left, right),
                        swc_ecma_ast::BinaryOp::GtEq => Instr::CmpGE(dest, left, right),
                        swc_ecma_ast::BinaryOp::EqEqEq => Instr::CmpEQ(dest, left, right),
                        swc_ecma_ast::BinaryOp::NotEqEq => Instr::CmpNE(dest, left, right),

                        // TODO TODO TODO This does not implement any of the 'wat' semantics of
                        // JavaScript See https://www.destroyallsoftware.com/talks/wat
                        swc_ecma_ast::BinaryOp::EqEq => Instr::CmpEQ(dest, left, right),
                        swc_ecma_ast::BinaryOp::NotEq => Instr::CmpNE(dest, left, right),

                        swc_ecma_ast::BinaryOp::InstanceOf => {
                            Instr::IsInstanceOf(dest, left, right)
                        }
                        _ => panic!("unsupported binary op: {:?}", op),
                    };
                    cplr.emit(instr);
                }
            }
            dest
        }
        Expr::StringLiteral(lit) => {
            let dest = get_dest(cplr);
            compile_load_const(cplr, dest, bytecode::Literal::String(lit.to_string()));
            dest
        }
        Expr::SymbolLiteral(lit) => {
            let dest = get_dest(cplr);
            compile_load_const(cplr, dest, bytecode::Literal::Symbol(lit));
            dest
        }
        Expr::NumberLiteral(lit) => {
            let dest = get_dest(cplr);
            compile_load_const(cplr, dest, bytecode::Literal::Number(*lit));
            dest
        }
        Expr::BoolLiteral(lit) => {
            let dest = get_dest(cplr);
            compile_load_const(cplr, dest, bytecode::Literal::Bool(*lit));
            dest
        }
        Expr::ArrayCreate => {
            let array = get_dest(cplr);
            let constructor: bytecode::VReg = compile_read_global(cplr, "Array".into());
            complex::compile_new(cplr, array, constructor, &[]);
            array
        }
        Expr::ArrayNth { arr, index } => {
            let arr = compile_expr(cplr, None, block, *arr);
            let index = compile_expr(cplr, None, block, *index);
            let dest = get_dest(cplr);
            cplr.emit(Instr::ArrayNth { dest, arr, index });
            dest
        }
        Expr::ArrayLen(arr) => {
            let arr = compile_expr(cplr, None, block, *arr);
            let dest = get_dest(cplr);
            cplr.emit(Instr::ArrayLen { dest, arr });
            dest
        }
        Expr::ObjectCreate => {
            let obj = get_dest(cplr);
            cplr.emit(Instr::ObjCreateEmpty(obj));
            obj
        }

        Expr::ObjectGet { obj, key } => {
            let obj = compile_expr(cplr, None, block, *obj);
            let key = compile_expr(cplr, None, block, *key);
            let dest = get_dest(cplr);
            cplr.emit(Instr::ObjGet { dest, obj, key });
            dest
        }
        Expr::ObjectGetKeys(obj) => {
            let obj = compile_expr(cplr, None, block, *obj);
            let dest = get_dest(cplr);
            cplr.emit(Instr::ObjGetKeysOE { dest, obj });
            dest
        }
        Expr::CreateClosure { func } => {
            let mut cap_names = Vec::new();
            let mut cap_regs = Vec::new();

            for name in func.as_ref().unbound_names.iter() {
                let name = DeclName::Js(name.clone());
                match cplr.resolve_name(&name) {
                    Loc::Reg(reg) => {
                        cap_names.push(name.clone());
                        cap_regs.push(reg);
                    }
                    Loc::Global(_) => {
                        // skip: the inner function will *also* see the name as global and
                        // compile the appropriate access to globalThis
                    }
                }
            }

            let lfnid = {
                let (globals, module_builder) = cplr.suspend();
                compile_function(globals, module_builder, cap_names, func)
            };
            let dest = get_dest(cplr);
            cplr.emit(Instr::ClosureNew {
                dest,
                fnid: lfnid,
                forced_this: None,
            });

            for reg in cap_regs {
                cplr.emit(Instr::ClosureAddCapture(reg));
            }

            {
                let key = cplr.gen_reg();

                // <function_object>.prototype = {}
                compile_load_const(cplr, key, Literal::String("prototype".to_string()));
                let proto = cplr.gen_reg();
                cplr.emit(Instr::ObjCreateEmpty(proto));
                cplr.emit(Instr::ObjSet {
                    obj: dest,
                    key,
                    value: proto,
                });

                // <function_object>.constructor = globalThis.Function
                let ctor = compile_read_global(cplr, "Function".into());
                compile_load_const(cplr, key, Literal::String("constructor".to_string()));
                cplr.emit(Instr::ObjSetN {
                    obj: dest,
                    key,
                    value: ctor,
                });
            }

            dest
        }
        Expr::Call {
            callee: callee_eid,
            args,
        } => {
            match block.get_expr(*callee_eid) {
                // Some things expressed in the `f(...)` call syntax are not actually calls to
                // anything, but have a special meaning
                Expr::Read(DeclName::Js(name)) if name == "sink" => {
                    for arg in args {
                        let var = compile_expr(cplr, None, block, *arg);
                        cplr.emit(Instr::PushToSink(var));
                    }

                    let dest = get_dest(cplr);
                    compile_load_const(cplr, dest, Literal::Undefined);
                    dest
                }
                Expr::Read(DeclName::Js(name)) if name == "eval" => {
                    panic!("`eval` not supported")
                }
                callee => {
                    let mut arg_regs = Vec::new();
                    for arg in args {
                        let reg = compile_expr(cplr, None, block, *arg);
                        arg_regs.push(reg);
                    }

                    let (this, callee) = match callee {
                        Expr::ObjectGet { obj, key } => {
                            let this = compile_expr(cplr, None, block, *obj);
                            let key = compile_expr(cplr, None, block, *key);
                            let callee = cplr.gen_reg();
                            cplr.emit(Instr::ObjGet {
                                dest: callee,
                                obj: this,
                                key,
                            });
                            (this, callee)
                        }
                        _ => {
                            let this = cplr.gen_reg();
                            let callee = compile_expr(cplr, None, block, *callee_eid);
                            // TODO 'this substitution'
                            cplr.emit(Instr::LoadUndefined(this));
                            (this, callee)
                        }
                    };

                    let return_value = get_dest(cplr);
                    cplr.emit(Instr::Call {
                        return_value,
                        this,
                        callee,
                    });

                    for reg in arg_regs {
                        cplr.emit(Instr::CallArg(reg));
                    }
                    return_value
                }
            }
        }

        Expr::New { constructor, args } => {
            let constructor = compile_expr(cplr, None, block, *constructor);
            let arg_regs: Vec<_> = args
                .iter()
                .map(|arg| compile_expr(cplr, None, block, *arg))
                .collect();

            let obj = get_dest(cplr);
            complex::compile_new(cplr, obj, constructor, &arg_regs);

            obj
        }

        Expr::CurrentException => {
            let dest = get_dest(cplr);
            cplr.emit(Instr::GetCurrentException(dest));
            dest
        }

        Expr::ImportModule { import_path } => {
            let dest = get_dest(cplr);
            let import_path_reg = cplr.gen_reg();
            compile_load_const(cplr, import_path_reg, Literal::JsWord(import_path.clone()));
            cplr.emit(Instr::ImportModule(dest, import_path_reg));
            dest
        }

        Expr::StringCreate => {
            let dest = get_dest(cplr);
            cplr.emit(Instr::StrCreateEmpty(dest));
            dest
        }

        Expr::RegexLiteral { pattern, flags } => {
            let obj = get_dest(cplr);
            let constructor = compile_read_global(cplr, "RegExp".into());

            let pattern_reg = cplr.gen_reg();
            compile_load_const(cplr, pattern_reg, Literal::String(pattern.clone()));

            let flags_reg = cplr.gen_reg();
            compile_load_const(cplr, flags_reg, Literal::String(flags.clone()));

            complex::compile_new(cplr, obj, constructor, &[pattern_reg, flags_reg]);

            obj
        }
        Expr::Error => panic!("malformed PAST: Expr::Error left behind by previous phase"),
    }
}

fn compile_block(cplr: &mut Compiler, block: &Block) {
    let stmts_count = block.stmts().count();
    cplr.block(block.id, stmts_count, |cplr| {
        compile_block_internal(cplr, block)
    })
}

fn compile_block_internal(cplr: &mut Compiler, block: &Block) {
    for decl in block.decls() {
        let reg = cplr.gen_reg();
        cplr.define_name(decl.name.clone(), reg);

        match decl.init {
            // Do nothing. TDZ is already the default for all VM registers.
            js_to_past::DeclInit::TDZ => {}
            js_to_past::DeclInit::Undefined => {
                cplr.emit(Instr::LoadUndefined(reg));
            }
        }
    }

    for fn_asmt in block.fn_asmts() {
        compile_assignment(cplr, &fn_asmt.var_name, block, fn_asmt.expr);
    }

    let mut iter = block.stmts();
    while compile_one_stmt(cplr, block, &mut iter) {}
}

mod builder {
    use std::collections::{HashMap, HashSet};

    use swc_atoms::JsWord;

    use super::{DeclName, StmtID};
    use crate::{
        bytecode::{self, builder},
        bytecode_compiler::{
            js_to_past::{self, StrictMode},
            CompiledModule,
        },
    };

    use bytecode::IID;
    use js_to_past::BlockID;

    pub(super) struct ModuleBuilder {
        fns: HashMap<bytecode::FnID, bytecode::Function>,
        next_fnid: u32,
        breakable_ranges: Vec<bytecode::BreakRange>,
    }
    impl ModuleBuilder {
        pub(super) fn new(min_fnid: u32) -> Self {
            ModuleBuilder {
                fns: HashMap::new(),
                next_fnid: min_fnid,
                breakable_ranges: Vec::new(),
            }
        }

        pub(super) fn gen_id(&mut self) -> bytecode::FnID {
            let lfnid = bytecode::FnID(self.next_fnid);
            self.next_fnid += 1;
            lfnid
        }

        pub(super) fn put_fn(&mut self, lfnid: bytecode::FnID, function: bytecode::Function) {
            self.fns.insert(lfnid, function);
        }

        pub(super) fn build(self, root_fnid: bytecode::FnID) -> CompiledModule {
            CompiledModule {
                root_fnid,
                functions: self.fns,
                breakable_ranges: self.breakable_ranges,
            }
        }
    }

    pub(super) struct Compiler<'a> {
        simple: bytecode::builder::FnBuilder,
        blocks: Vec<Block>,
        block_boundaries: HashMap<BlockID, (IID, IID)>,
        deferred_actions: Vec<BoxedAction>,

        strict_mode: StrictMode,

        globals: &'a HashSet<JsWord>,
        module_builder: &'a mut ModuleBuilder,
        fnid: bytecode::FnID,
    }

    type BoxedAction = Box<dyn FnOnce(&mut Compiler)>;

    struct Block {
        id: BlockID,
        names: HashMap<DeclName, bytecode::VReg>,
        iid_of_stmt: Box<[bytecode::IID]>,
        n_started_stmts: usize,
        deferred_actions: Vec<BoxedAction>,
    }

    pub enum Loc {
        Reg(bytecode::VReg),
        Global(JsWord),
    }

    impl<'a> std::convert::AsRef<builder::FnBuilder> for Compiler<'a> {
        fn as_ref(&self) -> &builder::FnBuilder {
            &self.simple
        }
    }

    impl<'a> Compiler<'a> {
        pub(super) fn new(
            globals: &'a HashSet<JsWord>,
            module_builder: &'a mut ModuleBuilder,
        ) -> Compiler<'a> {
            let lfnid = module_builder.gen_id();

            Compiler {
                simple: builder::FnBuilder::default(),
                blocks: Vec::new(),
                block_boundaries: HashMap::new(),
                strict_mode: StrictMode::Sloppy,
                globals,
                module_builder,
                deferred_actions: Vec::new(),
                fnid: lfnid,
            }
        }

        pub(super) fn set_strict_mode(&mut self, strict_mode: StrictMode) {
            if self.strict_mode == StrictMode::Strict {
                assert_eq!(strict_mode, StrictMode::Strict);
            } else {
                self.strict_mode = strict_mode;
            }
        }

        fn push_block(&mut self, block_id: BlockID, stmts_count: usize) {
            self.blocks.push(Block {
                id: block_id,
                names: HashMap::new(),
                // '+ 1' because we also map the one-past-the-end StmtID
                iid_of_stmt: (0..stmts_count + 1)
                    .map(|_| bytecode::IID(u16::MAX))
                    .collect(),
                n_started_stmts: 0,
                deferred_actions: Vec::new(),
            })
        }
        fn pop_block(&mut self) {
            let block = self.blocks.pop().unwrap();
            // check that every stmt has been marked (with `mark_stmt_start`)
            assert_eq!(block.n_started_stmts, block.iid_of_stmt.len());
        }
        fn cur_block_mut(&mut self) -> &mut Block {
            self.blocks.last_mut().unwrap()
        }
        pub(super) fn block<R>(
            &mut self,
            block_id: BlockID,
            stmts_count: usize,
            action: impl FnOnce(&mut Compiler) -> R,
        ) -> R {
            self.push_block(block_id, stmts_count);

            let iid_start = self.peek_iid();
            let ret = action(self);
            // Start one more statement and consider a StmtID that points to
            // one-past-the-end the list of stmts; it's still valid and its
            // corresponding IID is iid_end, which is one-past-the-end the list
            // of instructions.
            self.mark_stmt_start();
            let iid_end = self.peek_iid();

            let block = self.cur_block_mut();
            let deferred_actions = std::mem::take(&mut block.deferred_actions);
            let block_id = block.id;

            self.block_boundaries.insert(block_id, (iid_start, iid_end));
            for action in deferred_actions {
                action(self);
            }

            self.pop_block();
            ret
        }
        pub(super) fn define_name(&mut self, decl_name: DeclName, reg: bytecode::VReg) {
            let block = self.blocks.last_mut().unwrap();
            block.names.insert(decl_name, reg);
        }

        pub(super) fn gen_reg(&mut self) -> bytecode::VReg {
            self.simple.gen_reg()
        }
        pub(super) fn add_const(&mut self, lit: bytecode::Literal) -> bytecode::ConstIndex {
            self.simple.add_const(lit)
        }
        pub(super) fn peek_iid(&self) -> bytecode::IID {
            self.simple.peek_iid()
        }
        pub(super) fn emit(&mut self, instr: bytecode::Instr) {
            self.simple.emit(instr)
        }
        pub(super) fn reserve_instr(&mut self) -> bytecode::IID {
            self.simple.reserve_instr()
        }
        pub(super) fn set_instr(&mut self, iid: bytecode::IID, instr: bytecode::Instr) {
            self.simple.set_instr(iid, instr)
        }

        pub(super) fn mark_stmt_start(&mut self) {
            let iid = self.peek_iid();
            let block = self.blocks.last_mut().unwrap();

            let slot = &mut block.iid_of_stmt[block.n_started_stmts];
            // check that we haven't set the same slot twice
            debug_assert_eq!(slot.0, u16::MAX);
            *slot = iid;

            block.n_started_stmts += 1;
        }
        pub(super) fn iid_of_stmt(&mut self, stmt_id: StmtID) -> bytecode::IID {
            let block = self.blocks.last().unwrap();
            block.iid_of_stmt[stmt_id.numeric() as usize]
        }
        pub(super) fn block_boundaries(
            &mut self,
            block_id: js_to_past::BlockID,
        ) -> (bytecode::IID, bytecode::IID) {
            self.block_boundaries.get(&block_id).copied().unwrap()
        }

        pub(super) fn add_breakable_range(
            &mut self,
            span: swc_common::Span,
            iid_start: bytecode::IID,
            iid_end: bytecode::IID,
        ) {
            self.module_builder
                .breakable_ranges
                .push(bytecode::BreakRange {
                    lo: span.lo,
                    hi: span.hi,
                    fnid: self.fnid,
                    iid_start,
                    iid_end,
                });
        }

        pub(super) fn on_block_completion(&mut self, action: impl 'static + FnOnce(&mut Compiler)) {
            self.blocks
                .last_mut()
                .unwrap()
                .deferred_actions
                .push(Box::new(action));
        }

        pub(super) fn on_function_completion(
            &mut self,
            action: impl 'static + FnOnce(&mut Compiler),
        ) {
            self.deferred_actions.push(Box::new(action));
        }

        pub(super) fn build(mut self, span: swc_common::Span) -> bytecode::FnID {
            assert!(self.blocks.is_empty());

            let deferred_actions = std::mem::take(&mut self.deferred_actions);
            for action in deferred_actions {
                action(&mut self);
            }

            let mut bc_func = self.simple.build();
            bc_func.is_strict_mode = self.strict_mode == StrictMode::Strict;
            bc_func.span = span;

            self.module_builder.put_fn(self.fnid, bc_func);
            self.fnid
        }

        pub(crate) fn resolve_name(&self, name: &DeclName) -> Loc {
            let local_reg = self
                .blocks
                .iter()
                .rev()
                .find_map(|scope| scope.names.get(name).copied().map(Loc::Reg));

            if let Some(reg) = local_reg {
                return reg;
            }

            if let DeclName::Js(name) = name {
                if self.globals.contains(name) {
                    return Loc::Global(name.clone());
                }
            }
            panic!("malformed PAST: undeclared name: {:?}", name)
        }

        // this sucks lol
        pub(super) fn suspend(&mut self) -> (&mut &'a HashSet<JsWord>, &mut &'a mut ModuleBuilder) {
            (&mut self.globals, &mut self.module_builder)
        }
    }
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use crate::{bytecode, bytecode_compiler::CompiledModule};

    #[test]
    fn test_global_var() {
        quick_compile(
            "
                (function() {
                    (function() {
                        (function() {
                            let someLocalVar = 23;
                            console.log(someGlobalVar, someLocalVar)
                            someGlobalVar = 'lol'
                        })()
                    })()
                })()
                "
            .to_string(),
        );
    }

    #[test]
    fn test_let_and_var() {
        quick_compile(
            r#"(function() {
                    function f() { x = 1 }
                    let x = 5;
                    return f()
                })()
                "#
            .to_string(),
        );
    }

    #[test]
    fn test_function_before_let() {
        let compiled_module = quick_compile(
            "
                (function() {
                    function f() { x = 3 }
                    let x = 2;
                })()
                "
            .to_string(),
        );

        insta::assert_snapshot!(dump_functions(&compiled_module.functions));
    }

    #[test]
    fn test_func_decl() {
        let compiled_module = quick_compile(
            "function myFunction() {
                    return 3
                }"
            .to_string(),
        );

        insta::assert_snapshot!(dump_functions(&compiled_module.functions));
    }

    fn dump_functions(functions: &HashMap<bytecode::FnID, bytecode::Function>) -> String {
        let mut ids: Vec<_> = functions.keys().copied().collect();
        ids.sort();

        let mut buf = String::new();
        for fnid in ids {
            use std::fmt::Write;

            let func = functions.get(&fnid).unwrap();
            writeln!(buf, "fn {:?}", fnid).unwrap();
            for (ndx, literal) in func.consts().iter().enumerate() {
                writeln!(buf, "  k{} {:?}", ndx, literal).unwrap();
            }
            for instr in func.instrs() {
                writeln!(buf, "  {:?}", instr).unwrap();
            }
        }

        buf
    }

    fn quick_compile(src: String) -> CompiledModule {
        let (swc_ast, source_map) = crate::bytecode_compiler::quick_parse_script(src);
        let past_function = super::js_to_past::compile_script(&swc_ast, source_map).unwrap();

        let mut module_builder = super::ModuleBuilder::new(0);
        let globals = past_function.unbound_names.iter().cloned().collect();
        let root_lfnid =
            super::compile_function(&globals, &mut module_builder, Vec::new(), &past_function);

        module_builder.build(root_lfnid)
    }
}

mod complex {
    // This module contains "complex instructions": bytecode templates for
    // operations that can be seen as self-contained but are broken down into
    // lower-level instructions during the compilation process.

    use super::*;

    pub(super) fn compile_new(
        cplr: &mut Compiler,
        obj: bytecode::VReg,
        constructor: bytecode::VReg,
        arg_regs: &[bytecode::VReg],
    ) {
        cplr.emit(Instr::ObjCreateEmpty(obj));

        {
            // return value is discarded
            let return_value = cplr.gen_reg();
            cplr.emit(Instr::Call {
                return_value,
                this: obj,
                callee: constructor,
            });
        }

        for reg in arg_regs {
            cplr.emit(Instr::CallArg(*reg));
        }

        let key = cplr.gen_reg();

        let prototype = cplr.gen_reg();
        compile_load_const(cplr, key, Literal::String("prototype".into()));
        cplr.emit(Instr::ObjGet {
            dest: prototype,
            obj: constructor,
            key,
        });

        compile_load_const(cplr, key, Literal::String("__proto__".into()));
        cplr.emit(Instr::ObjSet {
            obj,
            key,
            value: prototype,
        });

        compile_load_const(cplr, key, Literal::String("constructor".into()));
        cplr.emit(Instr::ObjSetN {
            obj,
            key,
            value: constructor,
        });
    }

    pub(super) fn compile_to_primitive(cplr: &mut Compiler, arg: bytecode::VReg) -> bytecode::VReg {
        #![allow(non_snake_case)]

        let lit_valueOf = cplr.add_const(Literal::JsWord("valueOf".into()));
        let lit_toString = cplr.add_const(Literal::JsWord("toString".into()));

        let key = cplr.gen_reg();
        let property = cplr.gen_reg();
        let value = cplr.gen_reg();

        cplr.emit(Instr::Copy {
            dst: value,
            src: arg,
        });
        let jmp_if_arg_primitive = cplr.reserve_instr();

        let mut jmp_if_ret_primitive0 = bytecode::IID(0);
        let mut jmp_if_ret_primitive1 = bytecode::IID(0);

        for (name, jmp_if_ret_primitive) in [
            (lit_valueOf, &mut jmp_if_ret_primitive0),
            (lit_toString, &mut jmp_if_ret_primitive1),
        ] {
            cplr.emit(Instr::LoadConst(key, name));
            cplr.emit(Instr::ObjGet {
                dest: property,
                obj: arg,
                key,
            });
            let jmp_if_property_not_closure = cplr.reserve_instr();

            cplr.emit(Instr::Call {
                return_value: value,
                this: arg,
                callee: property,
            });
            *jmp_if_ret_primitive = cplr.reserve_instr();

            let next = cplr.peek_iid();

            cplr.set_instr(
                jmp_if_property_not_closure,
                Instr::JmpIfNotClosure {
                    arg: property,
                    dest: next,
                },
            );
        }

        // TODO These "standard exceptions" should be created at initialization
        // and reused instead of recreated every time
        let k_message = cplr.add_const(Literal::String("Cannot convert to primitive".to_string()));
        let message = cplr.gen_reg();
        cplr.emit(Instr::LoadConst(message, k_message));

        let TypeError = cplr.gen_reg();
        let k_TypeError = cplr.add_const(Literal::String("TypeError".to_string()));
        cplr.emit(Instr::GetGlobal {
            dest: TypeError,
            name: k_TypeError,
        });
        let exc = cplr.gen_reg();
        compile_new(cplr, exc, TypeError, &[message]);
        cplr.emit(Instr::Throw(exc));

        let L_success = cplr.peek_iid();

        cplr.set_instr(
            jmp_if_ret_primitive0,
            Instr::JmpIfPrimitive {
                arg: value,
                dest: L_success,
            },
        );
        cplr.set_instr(
            jmp_if_ret_primitive1,
            Instr::JmpIfPrimitive {
                arg: value,
                dest: L_success,
            },
        );
        cplr.set_instr(
            jmp_if_arg_primitive,
            Instr::JmpIfPrimitive {
                arg,
                dest: L_success,
            },
        );

        value
    }
}
